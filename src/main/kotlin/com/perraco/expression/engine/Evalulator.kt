/*
 * Copyright (c) 2024 Perraco Labs. All rights reserved.
 * This work is licensed under the terms of the MIT license.
 * For a copy, see <https://opensource.org/licenses/MIT>
 */

package com.perraco.expression.engine

import com.perraco.expression.functions.EvalFunction
import com.perraco.expression.functions.FunctionRegistry

/**
 * Evaluates abstract syntax tree nodes generated by the [Parser].
 *
 * It supports various types of nodes including numbers,
 * binary operations, functions, text literals, and unary operations.
 */
class Evaluator(private val decimalPlaces: Int = DECIMAL_PLACES) {

    /**
     * Evaluates the given input string and returns the evaluation result.
     *
     * @param input The input string to be evaluated.
     * @return The result of the evaluation, or null if the input is empty.
     * @throws EvalException If there is an error during the evaluation.
     */
    fun evaluate(input: String): Any? {
        try {
            val treeRoot: ASTNode? = Parser(input = input).parse()

            treeRoot?.let { root ->
                val evaluation: Any = Evaluator().evaluateNode(node = root)

                if (evaluation is Double) {
                    return formatDoubleWithoutTrailingZeros(value = evaluation)
                }

                return evaluation
            }
        } catch (e: Exception) {
            throw EvalException(message = "Error evaluating expression: ${e.message}")
        }

        return null
    }

    private fun formatDoubleWithoutTrailingZeros(value: Double): String {
        val formattedValue: String = String.format("%.${decimalPlaces}f", value)
        return if (formattedValue.contains(other = ".") && formattedValue.endsWith(suffix = "0")) {
            formattedValue.replace(regex = "0*$".toRegex(), replacement = "")
                .replace(regex = "\\.$".toRegex(), replacement = "")
        } else {
            formattedValue
        }
    }

    /**
     * Evaluates the given [ASTNode] and returns the evaluation result.
     *
     * @param node The AST node to be evaluated.
     * @return The result of the evaluation.
     * @throws EvalException If there is an error during the evaluation.
     */
    private fun evaluateNode(node: ASTNode): Any {
        return when (node) {
            is ASTNode.NumberNode -> node.value
            is ASTNode.TextNode -> node.value
            is ASTNode.BinaryOperationNode -> evaluateBinaryOperation(node = node)
            is ASTNode.UnaryOperationNode -> evaluateUnaryOperation(node = node)
            is ASTNode.FunctionNode -> evaluateFunction(node = node)
        }
    }

    /**
     * Evaluates a binary operation node.
     *
     * @param node The binary operation node to evaluate.
     * @return The result of the binary operation.
     * @throws EvalException If an unknown operator is encountered.
     */
    private fun evaluateBinaryOperation(node: ASTNode.BinaryOperationNode): Any {
        val left: Double = evaluateNode(node = node.left).toString().toDouble()
        val right: Double = evaluateNode(node = node.right).toString().toDouble()

        return when (node.operator.type) {
            Token.Type.PLUS -> left.plus(other = right)
            Token.Type.MINUS -> left.minus(other = right)
            Token.Type.MULTIPLY -> left.times(other = right)
            Token.Type.DIVIDE -> left.div(other = right)
            Token.Type.MODULO -> left.mod(other = right)
            else -> throw EvalException(message = "Unknown binary operator: ${node.operator.type}")
        }
    }

    /**
     * Evaluates a function node by invoking the corresponding function
     * from the [FunctionRegistry].
     *
     * @param node The function node to evaluate.
     * @return The result of the function evaluation.
     * @throws EvalException If the function is not found in the registry.
     */
    private fun evaluateFunction(node: ASTNode.FunctionNode): Any {
        val functionName: String = node.name

        val evalFunction: EvalFunction = FunctionRegistry.get(name = functionName)
            ?: throw EvalException(message = "Function '$functionName' not found")

        val evaluatedArguments: List<Any> = node.arguments.map { evaluateNode(node = it) }
        return evalFunction.evaluate(arguments = evaluatedArguments)
    }

    /**
     * Evaluates a unary operation node.
     *
     * @param node The unary operation node to evaluate.
     * @return The result of the unary operation.
     * @throws EvalException If an unknown unary operator is encountered.
     */
    private fun evaluateUnaryOperation(node: ASTNode.UnaryOperationNode): Any {
        val operand: Double = evaluateNode(node = node.operand) as Double

        return when (node.operator.type) {
            Token.Type.MINUS -> -operand
            Token.Type.PLUS -> operand
            else -> throw EvalException(message = "Unknown unary operator: ${node.operator.type}")
        }
    }

    companion object {
        /** The default number of decimal places to round to. */
        private const val DECIMAL_PLACES: Int = 4
    }
}

/**
 * Exception class for handling evaluation errors.
 *
 * @param message The error message describing the evaluation error.
 */
class EvalException(message: String) : Exception(message)
